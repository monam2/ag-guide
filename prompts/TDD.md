# TDD(Test Driven Development)

- 테스트 코드를 먼저 작성.
- 테스트를 통과하는 최소한의 코드를 구현한 후 리팩토링한다.

```
[전통적인 개발 순서]
코드 작성 -> 테스트 코드 작성 -> 버그 발견 -> 수정
(반복)

[TDD 개발 순서]
테스트 코드 작성 -> 코드 작성 -> 리팩토링
(반복)
```

없는 코드를 테스트하는게 의미없이 느껴질 수 있지만, TDD의 가치는 테스트 자체가 아니라 설계 과정에 있다.

테스트를 먼저 작성하면이 함수가 어떻게 호출되어야 하는지, 어떤 입력을 받고 어떤 출력을 내야 하는지 먼저 생각하게 된다.

구현이 아닌, 인터페이스와 동작을 먼저 명확히 정의하는 것이다.

## 레드-그린-리팩터 사이클

테스트 코드를 먼저 작성하고 이를 바탕으로 실제 코드를 점진적으로 완성해나가는 TDD의 표준 작업 절차이다.

```
[레드-그린-리팩터 사이클]
1. 테스트 작성 및 실패(레드)
2. 최소한의 실제 코드 작성(그린)
3. 리팩토링으로 완성도 높이기(리팩터)
```

### 레드 Stage

- 이 단계에서 테스트는 반드시 실패해야 한다.
- 아직 구현 코드가 없기 때문. 추후 작성할 코드가 어떻게 동작할지 상상해서 작성한다.

```javascript
// 아직 존재하지 않는 함수 테스트
describe("calculateTotal", () => {
  it("should calculate total with tax", () => {
    // 테스트하고 싶은 인수와 함께 실제 함수 실행
    // 첫 번째 인수 + (첫 번째 인수 * 두 번째 인수)를 실행하는 함수
    const result = calculateTotal(100, 0.1);

    // 반환 값 확인: 100 + (100 * 0.1) = 110 예측
    expect(result).toBe(110);
  });
});
```

이 테스트는 당연히 실패한다. 테스트할 코드인 `calculateTotal` 함수가 아직 존재하지 않기 때문. 하지만 이 코드에는 중요한 정보가 있다. 100원의 상품에 10% 세금이 붙으면 110원이어야 한다고 적혀있다.

### 그린 Stage

- 이 단계에서 테스트는 반드시 통과해야 한다.
- 테스트를 통과하는 가장 간단한 코드를 작성한다.

```typescript
// 테스트를 통과하는 가장 간단한 코드
function calculateTotal(price: number, taxRate: number): number {
  return price + price * taxRate;
}
```

이 단계에선 코드의 품질을 걱정하지 않는다. 테스트를 일단 통과하는 것을 목표로 한다.

### 리팩터 Stage

테스트가 통과하면 코드를 개선한다. 리팩터 단계에서 중복제거, 성능 최적화, 가독성 향상 등이 이루어진다.
중요한 것은 리팩터링 후에도 테스트에 계속 통과해야 한다는 것이다. 테스트가 리팩터링의 안전망 역할을 한다.

```typescript
// 리팩터링 후 코드
function calculateTotal(basePrice: number, taxRate: number): number {
  const taxAmount = basePrice * taxRate;
  return basePrice + taxAmount;
}
```

TDD는 이 세 단계를 반복하며 프로그램을 구축한다. AI는 대화가 매우 길어지거나 새로운 대화를 시작할 때 이전의 기억을 잊어버린다. 그래서 개발자는 프로젝트의 문맥을 기록한다. 기억을 잃은 AI가 문서를 보고 바로 작업할 수 있도록 하는 것이다. 테스트 코드는 중요한 문맥이며, 코드의 입력과 출력을 어떻게 해야하는지 모두 보인다. 이전 대화에서 작성한 코드의 의도를 파악할 수 있는 수단이 된다.

## TDD 장점과 한계

### 장점

- 버그 조기 발견 : 테스트가 먼저 있으니 코드를 작성하는 즉시 버그를 발견한다. 버그는 발견이 늦을수록 수정 비용이 기하급수적으로 증가한다.
- 자연스러운 문서화 : 테스트 코드 자체가 코드 설명서 역할을 한다. 주석은 거짓말을 할 수 있지만 테스트는 거짓말을 할 수 없다.
- 리팩터링에 대한 자신감 : 테스트가 있으면 코드를 과감하게 수정할 수 있다. 리팩터링 후에도 테스트에 통과하는지 확인할 수 있기 때문이다.
- 더 나은 설계 : 테스트하기 쉬운 코드는 대체로 좋은 설계를 가진다. TDD를 하다보면 자연스럽게 단일 책임 원칙을 따르고 의존성을 분리하게 된다.
- 장기적 개발 속도 향상 : 프로젝트가 커질수록 TDD를 적용한 프로젝트는 그렇지 않은 프로젝트보다 빠르게 진행된다. 디버깅 시간이 크게 줄어들기 때문이다.

### 한계

- 초기 시간 투자 : 테스트를 먼저 작성하는 것은 추가 시간이 필요하다. 프로토타입이나 MVP단계에서는 부담이 될 수 있따.
- 잘못된 테스트의 위험: 테스트 자체가 잘못되면 오히려 해가 된다. 테스트만 믿고 안심할 수 있기 때문이다.
- 모든 것을 테스트하기 어려움 : UI, 외부 API 연동, 비동기 이벤트 등은 테스트하기 어렵다. TDD가 모든 상황에 적합하지는 않다.
- 유지보수 비용 : 테스트 코드도 유지보수가 필요하다. 코드가 변경되면 테스트도 함께 변경해야 한다.

## Antigravity에서 TDD 적용하기

가장 중요한 것은 프롬프트이다. 에이전트에게 테스트를 먼저 작성하라고 반드시 요청해야 한다. 실제 코드를 작성하기 전에 테스트 코드가 실패하는 것을 꼭 확인하도록 명시한다. 그 다음 테스트 코드가 통과되는 코드를 작성하도록 유도한다. 마지막으로 코드를 개선해 좋은 코드로 만든다. 앞서 설명했던 레드, 그린, 리팩터 단계를 그대로 따라간다.

```
[Task]
사용자 로그인 기능을 TDD 방식으로 구현해줘.

[TDD 단계]
1. 먼저 테스트 케이스를 작성해줘
2. 테스트가 실패하는 것을 확인한 후 구현 코드를 작성해줘
3. 테스트가 통과하면 리팩터링해줘

[테스트 케이스 요구 사항]
- 올바른 이메일/비밀번호로 로그인 성공
- 잘못된 이메일/비밀번호로 로그인 실패
- 빈 이메일 입력 시 오류
- 빈 비밀번호 입력 시 오류

[기술 스택]
- Jest + TypeScript
- 함수명: loginUser(email: string, password: string)
```

이에 더해서 체크 박스를 사용해서 단계 별 기능을 정의하고 작업하면서 체크하는 등 상세한 기능 정의와 구현 과정을 프롬프팅하면 된다.
