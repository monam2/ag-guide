# Clean Architecture

"비즈니스 로직(서비스의 핵심 로직)을 외부 세계로부터 보호하라."

비즈니스 로직은 어떤 프레임워크를 사용해도, 어떤 DB를 사용해도 변하지 않는다. 이 로직이 바뀌는 건 서비스의 본질 자체가 바뀐다는 것을 의미한다. 핵심 비즈니스 로직은 외부의 변화에 영향을 받지 않아야 한다. 이를 위해선 **비즈니스 로직이 외부 기술에 의존하면 안된다.**

프로젝트를 MongoDB에서 PgSql로 마이그레이션한다고 해보자. 클린 아키텍쳐를 따랐다면 리포지터리 계층만 교체하면 될 것이다. 하지만 비즈니스 로직 곳곳에 MongoDB의 ObjectId나 $lookup 같은 기술이 침투해 있으면 전체 코드를 뒤져가며 수정해야 한다. 이것이 외부 요구 사항에 의해 서비스의 핵심 로직을 변경해야 하는 상황이다.

## 레이어 분리

클린 아키텍쳐는 소프트웨어를 동심원 형태의 레이어로 분리한다. 안쪽 레이어일수록 추상화 수준이 높고, 바깥쪽일수록 구체적인 구현이다. 아키텍쳐는 수학 공식이 아니고 추상적인 개념이다. 개발자마다 레이어를 다르게 나눌 수 있다.

| 레이어                | 역할                            | 예시                              |
| :-------------------- | :------------------------------ | :-------------------------------- |
| 엔티티                | 핵심 비즈니스 규칙              | User, Order, Product 엔티티       |
| 유스케이스            | 애플리케이션 고유 비즈니스 규칙 | CreateOrder, AuthenticateUser     |
| 인터페이스 어댑터     | 데이터 형식 변환                | Controller, Presenter, Repository |
| 프레임워크와 드라이버 | 외부 도구와 프레임워크          | Express, Postgresql, 리액트       |

### 엔티티

- 비즈니스 로직의 가장 중요한 객체를 코드화한 결과.
- ex. 할 일 목록 앱 -> 할 일 객체(고유 ID, 해야할 일의 내용, 완료 여부, 생성 날짜 등)

### 유스케이스

- 애플리케이션의 고유 비즈니스 규칙을 정의.
- 중요한 도메인 로직을 정의하고 그 과정에서 엔티티를 불러와서 사용 -> "의존한다."
  - 의존한다? : 엔티티가 변경되면 유스케이스도 영향을 받기 때문 => 엔티티에 의존한다.

### 인터페이스 어댑터

- 외부의 입력을 받거나 도메인에서 나가는 아웃풋을 변환하는 역할 또는 인터페이스 역할.
- 유스케이스 입력 포트, 유스케이스 출력 포트를 통해 도메인 레이어와 상호작용 한다.

### 프레임워크와 드라이버

- 이외 모든 것.
- DB, HTTP 서버, UI 라이브러리 등
- 해당 영역은 도메인 영역으로부터 분리되어야 한다. 언제든지 변경될 수 있고 개발자에게 결정권이 없다.

### 레이어드 아키텍쳐 vs 클린 아키텍쳐

레이어드 아키텍쳐는 요청이 들어오면 로직을 거쳐 결과를 내보낸다. 입력부터 출력까지 일렬로 의존하는 관계. -> 웹 프레임워크나 DB가 바뀌면 그 영향이 도메인 로직까지 전달.

클린 아키텍쳐는 의존성 역전(Dependency Inversion)을 통해 레이어드 아키텍쳐와 반대를 유지한다. 도메인이 외부에 의존하지 않고 외부가 도메인에 의존한다. 쉽게 외부 의존성을 교체할 수 있고 도메인 로직이 영향받지 않도록 만든다. 즉, 리팩토링이 쉬워지고 프로젝트가 가벼워진다.

의존성 역적을 구현하기 위한 구체적인 규칙이 유스케이스 입력/출력 포트이다. 외부는 유스케이스에 직접 붙지 못하고 입력 포트를 통해서만 유스케이스를 호출해야 한다. 유스케이스는 DB, 메시지, 외부 API 같은 것들을 직접 호출하지 않고 출력 포트에만 의존한다. 이렇게 경계를 정해두면 의존성을 뒤집는 지점과 방식이 자연스럽게 고정된다.

## 클린 아키텍쳐 장/단점

장점:

- 비즈니스 로직 보호: 핵심 비즈니스 로직이 프레임워크, 데이터베이스, 외부 라이브러리에 의존하지 않는다. 기술 스택이 변경되더라도 비즈니스 규칙은 그대로 유지된다. 이는 장기적으로 매우 큰 자산이 된다.
- 변경에 강한 구조: DB 교체, ORM 변경, REST-gRPC 전환과 같은 변화가 발생해도 외부 레이어만 수정하면 된다. 변화의 영향 범위를 구조적으로 제한할 수 있다.
- 테스트 용이성: 유스케이스와 도메인 로직은 순수한 코드에 가깝다. DB나 서버 없이도 테스트할 수 있다. Mock 객체만 있으면 된다. TDD 및 자동화 테스트와 궁합이 매우 좋다.
- 의존성 관리의 명확성: 의존성 방향이 강제되므로 참조 위치와 대상이 명확하다. 서비스가 커질수록 발생하는 순환 의존성, God Service 문제를 구조적으로 예방한다.
- 팀 협업에 유리: 레이어별 책임이 명확해 역할 분담이 쉬워진다. 코드 리뷰를 위한 명확한 기준이 생긴다.

단점:

- 초기 진입 장벽: 개념이 많고 구조가 복잡해서 초보 개발자에게는 부담이 크다. 포트, 어댑터, 유스케이스 개념을 이해하지 못하면 오히려 생산성이 떨어질 수 있다.
- 보일러플레이트 코드 증가: 인터페이스, DTO, Mapper, 유스케이스 등 파일 수가 급격히 늘어난다. 단순 CRUD에도 구조가 과해보일 수 있다.
- 초기 개발 속도 저하: 빠르게 기능을 만들어야 하는 초기 단계에서는 비효율적으로 느껴질 수 있다. MVP나 프로토타입 단계에서는 과한 구조일 수 있다.
- 과도한 추상화의 위협: 모든 로직을 무조건 분리하면 오히려 가독성이 떨어질 수 있다. '클린 아키텍쳐를 위한 클린 아키텍쳐'가 될 수도 있다.
